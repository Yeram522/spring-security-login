<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Î≥¥Ïïà Í¥ÄÏ†úÏÑºÌÑ∞</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        /* Í∏∞Ï°¥ Ïä§ÌÉÄÏùºÍ≥º ÎèôÏùº */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connection-status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-toast {
            position: fixed;
            top: 60px;
            right: 10px;
            min-width: 350px;
            max-width: 500px;
            background: white;
            border-left: 4px solid #007bff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px;
            margin-bottom: 10px;
            z-index: 1001;
            animation: slideIn 0.3s ease-out;
        }

        .alert-toast.severity-critical {
            border-left-color: #dc3545;
            background: #fff5f5;
        }

        .alert-toast.severity-high {
            border-left-color: #fd7e14;
            background: #fff8f0;
        }

        .alert-toast.severity-medium {
            border-left-color: #ffc107;
            background: #fffbf0;
        }

        .alert-toast.severity-low {
            border-left-color: #28a745;
            background: #f0fff4;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .alert-time {
            font-size: 0.85em;
            color: #666;
        }

        .alert-body {
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .alert-actions {
            display: flex;
            gap: 8px;
        }

        .alert-actions button {
            padding: 4px 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .alert-actions button:hover {
            background: #f8f9fa;
        }

        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s ease;
        }

        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2em;
            text-align: center;
            margin-bottom: 15px;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status-item.online {
            background: #d4edda;
            color: #155724;
        }

        .status-item.warning {
            background: #fff3cd;
            color: #856404;
        }

        .status-item.critical {
            background: #f8d7da;
            color: #721c24;
        }

        .status-item.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 8px 16px;
            border: 1px solid #007bff;
            background: #007bff;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .controls button:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .controls button.secondary {
            background: white;
            color: #007bff;
        }

        .controls button.secondary:hover {
            background: #f8f9fa;
        }

        .dashboard {
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric {
            text-align: center;
            padding: 20px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .metric::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .metric.critical {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
        }

        .metric.critical::before {
            background: #f44336;
        }

        .metric.warning {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
        }

        .metric.warning::before {
            background: #ff9800;
        }

        .metric.normal {
            background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
        }

        .metric.normal::before {
            background: #4caf50;
        }

        .metric.info {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
        }

        .metric.info::before {
            background: #2196f3;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .metric-label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 15px;
        }

        .threat-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .threat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #dc3545;
            transition: all 0.3s ease;
        }

        .threat-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .threat-ip {
            font-family: monospace;
            font-weight: bold;
            color: #dc3545;
        }

        .threat-count {
            background: #dc3545;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .update-time {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .metric.critical .metric-value {
            animation: pulse 2s infinite;
            color: #d32f2f;
        }
    </style>
</head>
<body>
<div id="app">
    <!-- Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú -->
    <div :class="['connection-status', connectionStatus]">
        {{ connectionStatusText }}
    </div>

    <!-- Ìó§Îçî -->
    <div class="header">
        <h1>üõ°Ô∏è Î≥¥Ïïà Í¥ÄÏ†úÏÑºÌÑ∞</h1>
        <div class="status-bar">
            <div class="status-item online">
                <span>üü¢</span> ÏãúÏä§ÌÖú Ï†ïÏÉÅ
            </div>
            <div class="status-item warning">
                <span>üü°</span> {{ metrics.warningCount || 0 }}Í∞ú Í≤ΩÍ≥†
            </div>
            <div class="status-item critical">
                <span>üî¥</span> {{ metrics.criticalAlerts || 0 }}Í∞ú Í∏¥Í∏â
            </div>
            <div class="status-item info">
                <span>üìä</span> Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ
            </div>
        </div>

        <div class="controls">
            <button @click="refreshAllData">
                üîÑ Ï†ÑÏ≤¥ ÏÉàÎ°úÍ≥†Ïπ®
            </button>
            <button @click="testAlert" class="secondary">
                üß™ ÌÖåÏä§Ìä∏ ÏïåÎ¶º
            </button>
            <button @click="exportReport" class="secondary">
                üìä Î¶¨Ìè¨Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
            </button>
            <select v-model="selectedTimeRange" @change="updateTimeRange">
                <option value="15m">ÏµúÍ∑º 15Î∂Ñ</option>
                <option value="1h">ÏµúÍ∑º 1ÏãúÍ∞Ñ</option>
                <option value="24h">ÏµúÍ∑º 24ÏãúÍ∞Ñ</option>
                <option value="7d">ÏµúÍ∑º 7Ïùº</option>
            </select>
        </div>
    </div>

    <!-- ÎåÄÏãúÎ≥¥Îìú -->
    <div class="dashboard">
        <!-- Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà ÏßÄÌëú -->
        <div class="card">
            <h3>üìä Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà ÏßÄÌëú</h3>
            <div class="metrics-grid">
                <div class="metric critical">
                    <div class="metric-value">{{ metrics.criticalAlerts || 0 }}</div>
                    <div class="metric-label">Í∏¥Í∏â ÏïåÎ¶º</div>
                </div>
                <div class="metric warning">
                    <div class="metric-value">{{ metrics.blockedIps || 0 }}</div>
                    <div class="metric-label">Ï∞®Îã®Îêú IP</div>
                </div>
                <div class="metric normal">
                    <div class="metric-value">{{ formatNumber(metrics.successfulLogins || 0) }}</div>
                    <div class="metric-label">Ï†ïÏÉÅ Î°úÍ∑∏Ïù∏</div>
                </div>
                <div class="metric info">
                    <div class="metric-value">{{ formatNumber(metrics.totalRequests || 0) }}</div>
                    <div class="metric-label">Ï¥ù ÏöîÏ≤≠ Ïàò</div>
                </div>
            </div>
        </div>

        <!-- Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Ï∂îÏù¥ -->
        <div class="card">
            <h3>üìà Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Ï∂îÏù¥</h3>
            <div class="chart-container">
                <canvas id="realTimeChart"></canvas>
            </div>
        </div>

        <!-- ÏÉÅÏúÑ ÏúÑÌòë IP -->
        <div class="card">
            <h3>üåç ÏÉÅÏúÑ ÏúÑÌòë IP TOP 10</h3>
            <div class="threat-list">
                <div v-for="threat in threatIps" :key="threat.ipAddress" class="threat-item"
                     :style="{ borderLeftColor: getThreatColor(threat.riskLevel) }">
                    <div>
                        <div class="threat-ip">{{ threat.ipAddress }}</div>
                        <small style="color: #666;">
                            üåç {{ threat.countryCode }} | {{ threat.attackTypes.join(', ') }}
                        </small>
                    </div>
                    <div class="threat-count" :style="{ background: getThreatColor(threat.riskLevel) }">
                        {{ threat.attackCount }}
                    </div>
                </div>
            </div>
        </div>

        <!-- ÏãúÍ∞ÑÎåÄÎ≥Ñ Í≥µÍ≤© Ìå®ÌÑ¥ -->
        <div class="card">
            <h3>‚è∞ ÏãúÍ∞ÑÎåÄÎ≥Ñ Í≥µÍ≤© Ìå®ÌÑ¥</h3>
            <div class="chart-container">
                <canvas id="hourlyChart"></canvas>
            </div>
        </div>

        <!-- ÏùëÎãµÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ -->
        <div class="card">
            <h3>‚ö° ÏãúÏä§ÌÖú ÏùëÎãµÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ</h3>
            <div class="chart-container">
                <canvas id="responseTimeChart"></canvas>
            </div>
        </div>
    </div>

    <!-- ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ -->
    <div class="update-time">
        ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏: {{ lastUpdateTime }}
    </div>

    <!-- ÏïåÎ¶º ÌÜ†Ïä§Ìä∏Îì§ -->
    <transition-group name="fade">
        <div v-for="alert in alerts" :key="alert.id"
             :class="['alert-toast', `severity-${alert.severity.toLowerCase()}`]">
            <div class="alert-header">
                <strong>{{ alert.title }}</strong>
                <span class="alert-time">{{ formatTime(alert.timestamp) }}</span>
            </div>
            <div class="alert-body" v-html="alert.message.replace(/\n/g, '<br>')"></div>
            <div class="alert-actions">
                <button @click="acknowledgeAlert(alert)">‚úÖ ÌôïÏù∏</button>
                <button @click="suppressAlert(alert, 1)">üîá 1ÏãúÍ∞Ñ ÏñµÏ†ú</button>
                <button v-if="alert.ipAddress && alert.ipAddress !== 'multiple_ips'"
                        @click="blockIp(alert.ipAddress)">üö´ IP Ï∞®Îã®
                </button>
                <button @click="removeAlert(alert.id)">‚ùå Îã´Í∏∞</button>
            </div>
        </div>
    </transition-group>
</div>

<script>
    const {createApp, ref, reactive, onMounted, onUnmounted, nextTick} = Vue;

    createApp({
        setup() {
            // Î∞òÏùëÌòï Îç∞Ïù¥ÌÑ∞
            const connectionStatus = ref('connecting');
            const connectionStatusText = ref('üîÑ Ïó∞Í≤∞ Ï§ë...');
            const selectedTimeRange = ref('1h');
            const lastUpdateTime = ref('--:--:--');
            const alerts = ref([]);

            const metrics = reactive({
                criticalAlerts: 0,
                blockedIps: 0,
                successfulLogins: 0,
                totalRequests: 0,
                warningCount: 0
            });

            const threatIps = ref([]);

            // Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§Îì§
            const charts = {};

            // Ï†ÑÏó≠ Î≥ÄÏàò
            let eventSource = null;
            let updateInterval = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 5;

            // SSE Ïó∞Í≤∞ Ìï®Ïàò
            function connectToAlertStream() {
                const token = localStorage.getItem('accessToken');

                const url = `/api/v1/admin/security/alerts/stream?token=${encodeURIComponent(token)}`;

                console.log('üîó SSE Ïó∞Í≤∞ ÏãúÎèÑ:', url);

                connectionStatus.value = 'connecting';
                connectionStatusText.value = 'üîÑ Ïó∞Í≤∞ Ï§ë...';

                eventSource = new EventSource(url);

                eventSource.onopen = (event) => {
                    console.log('‚úÖ SSE Ïó∞Í≤∞ ÏÑ±Í≥µ:', event);
                    connectionStatus.value = 'connected';
                    connectionStatusText.value = 'üü¢ Ïó∞Í≤∞Îê®';
                    reconnectAttempts = 0;
                };

                eventSource.onmessage = (event) => {
                    console.log('üì® SSE Î©îÏãúÏßÄ ÏàòÏã†:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'SECURITY_ALERT') {
                            handleSecurityAlert(data);
                        }
                    } catch (e) {
                        console.log('üìã ÌÖçÏä§Ìä∏ Î©îÏãúÏßÄ:', event.data);
                    }
                };

                eventSource.addEventListener('security_alert', (event) => {
                    console.log('üö® Î≥¥Ïïà ÏïåÎ¶º Ïù¥Î≤§Ìä∏:', event.data);
                    const alert = JSON.parse(event.data);
                    handleSecurityAlert(alert);
                });

                eventSource.addEventListener('connected', (event) => {
                    console.log('üéâ Ïó∞Í≤∞ ÏôÑÎ£å Ïù¥Î≤§Ìä∏:', event.data);
                    connectionStatus.value = 'connected';
                    connectionStatusText.value = 'üü¢ Ïó∞Í≤∞Îê®';
                });

                eventSource.onerror = (error) => {
                    console.error('‚ùå SSE Ïó∞Í≤∞ Ïò§Î•ò:', error);
                    connectionStatus.value = 'disconnected';
                    connectionStatusText.value = 'üî¥ Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê';

                    if (reconnectAttempts < maxReconnectAttempts) {
                        setTimeout(() => {
                            reconnectAttempts++;
                            console.log(`üîÑ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ${reconnectAttempts}/${maxReconnectAttempts}`);
                            connectToAlertStream();
                        }, 3000 * reconnectAttempts);
                    } else {
                        console.error('üíÄ ÏµúÎåÄ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò ÎèÑÎã¨');
                    }
                };
            }

            // Î≥¥Ïïà ÏïåÎ¶º Ï≤òÎ¶¨
            function handleSecurityAlert(alert) {
                console.log('üö® Î≥¥Ïïà ÏïåÎ¶º Ï≤òÎ¶¨:', alert);

                const newAlert = {
                    ...alert,
                    id: Date.now() + Math.random(),
                    timestamp: new Date()
                };

                alerts.value.push(newAlert);

                // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º
                if (Notification.permission === 'granted') {
                    new Notification(alert.title, {
                        body: alert.message,
                        icon: '/images/security-warning.png'
                    });
                }

                // Í∏¥Í∏â ÏïåÎ¶º Ïãú ÏÜåÎ¶¨
                if (alert.severity === 'CRITICAL') {
                    playAlertSound();
                }

                // 15Ï¥à ÌõÑ ÏûêÎèô Ï†úÍ±∞
                setTimeout(() => {
                    removeAlert(newAlert.id);
                }, 15000);
            }

            // ÏïåÎ¶º ÏÜåÎ¶¨ Ïû¨ÏÉù
            function playAlertSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (error) {
                    console.warn('ÏïåÎ¶º ÏÜåÎ¶¨ Ïû¨ÏÉù Ïã§Ìå®:', error);
                }
            }

            // ÏÉâÏÉÅ ÌåîÎ†àÌä∏
            const colors = {
                primary: '#3498db',
                danger: '#e74c3c',
                warning: '#f39c12',
                success: '#27ae60',
                info: '#17a2b8',
                purple: '#9b59b6'
            };

            // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú
            onMounted(async () => {
                console.log('üöÄ Vue Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ ÏãúÏûë');

                const token = localStorage.getItem('accessToken');
                if (!token) {
                    alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
                    window.location.href = '/login';
                    return;
                }

                // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠
                if (Notification.permission === 'default') {
                    const permission = await Notification.requestPermission();
                    console.log('üîî ÏïåÎ¶º Í∂åÌïú:', permission);
                }

                await nextTick();
                console.log('üìä Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî ÏãúÏûë');
                initializeCharts();

                console.log('üîó SSE Ïó∞Í≤∞ ÏãúÏûë');
                connectToAlertStream();

                console.log('üîÑ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë');
                startDataUpdates();

                console.log('‚úÖ Vue Ïª¥Ìè¨ÎÑåÌä∏ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
            });

            // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú
            onUnmounted(() => {
                console.log('üõë Vue Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏');

                if (eventSource) {
                    eventSource.close();
                    console.log('üîå SSE Ïó∞Í≤∞ Ï¢ÖÎ£å');
                }
                if (updateInterval) {
                    clearInterval(updateInterval);
                    console.log('‚è∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨');
                }
            });

            // Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî
            function initializeCharts() {
                console.log('üìä Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî ÏãúÏûë');

                try {
                    // 1. Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Ï∂îÏù¥
                    const ctx1 = document.getElementById('realTimeChart');
                    if (!ctx1) {
                        console.error('‚ùå realTimeChart Ï∫îÎ≤ÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
                        return;
                    }

                    charts.realTime = new Chart(ctx1.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Î∏åÎ£®Ìä∏Ìè¨Ïä§ Í≥µÍ≤©',
                                    data: [],
                                    borderColor: colors.danger,
                                    backgroundColor: colors.danger + '20',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    label: 'DDoS Í≥µÍ≤©',
                                    data: [],
                                    borderColor: colors.warning,
                                    backgroundColor: colors.warning + '20',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    label: 'Ïä§Ï∫êÎãù ÏãúÎèÑ',
                                    data: [],
                                    borderColor: colors.info,
                                    backgroundColor: colors.info + '20',
                                    tension: 0.4,
                                    fill: true
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {position: 'top'}
                            },
                            scales: {
                                y: {beginAtZero: true}
                            }
                        }
                    });

                    // 2. ÏãúÍ∞ÑÎåÄÎ≥Ñ Ìå®ÌÑ¥
                    const ctx3 = document.getElementById('hourlyChart');
                    if (!ctx3) {
                        console.error('‚ùå hourlyChart Ï∫îÎ≤ÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
                        return;
                    }
                    charts.hourly = new Chart(ctx3.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: Array.from({length: 24}, (_, i) => i.toString().padStart(2, '0') + ':00'),
                            datasets: [{
                                label: 'Í≥µÍ≤© ÏãúÎèÑ',
                                data: new Array(24).fill(0),
                                backgroundColor: colors.primary
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {beginAtZero: true}
                            }
                        }
                    });

                    // 3. ÏùëÎãµÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ
                    const ctx4 = document.getElementById('responseTimeChart');
                    if (!ctx4) {
                        console.error('‚ùå responseTimeChart Ï∫îÎ≤ÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
                        return;
                    }
                    charts.responseTime = new Chart(ctx4.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'ÌèâÍ∑† ÏùëÎãµÏãúÍ∞Ñ (ms)',
                                    data: [],
                                    borderColor: colors.primary,
                                    backgroundColor: colors.primary + '20',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    label: 'ÏûÑÍ≥ÑÍ∞í (500ms)',
                                    data: [],
                                    borderColor: colors.danger,
                                    borderDash: [5, 5],
                                    pointRadius: 0,
                                    fill: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {beginAtZero: true}
                            }
                        }
                    });
                } catch (error) {
                    console.error('‚ùå Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                    alert('Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥ Ï£ºÏÑ∏Ïöî.');
                }
            }

            // Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë
            function startDataUpdates() {
                updateData(); // Ï¶âÏãú Ïã§Ìñâ
                updateInterval = setInterval(updateData, 10000); // 10Ï¥àÎßàÎã§
            }

            // Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Ïã§Ï†ú API Ìò∏Ï∂ú)
            async function updateData() {
                const token = localStorage.getItem('accessToken');

                try {
                    // 1. Î≥¥Ïïà Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
                    const metricsResponse = await fetch(`/api/v1/admin/dashboard/metrics?timeRange=${selectedTimeRange.value}`, {
                        headers: {'Authorization': `Bearer ${token}`}
                    });

                    if (metricsResponse.ok) {
                        const metricsData = await metricsResponse.json();
                        if (metricsData.success) {
                            Object.assign(metrics, metricsData.data);
                        }
                    }

                    // 2. ÏúÑÌòë IP ÏóÖÎç∞Ïù¥Ìä∏
                    const threatsResponse = await fetch(`/api/v1/admin/dashboard/threats/top-ips?timeRange=${selectedTimeRange.value}`, {
                        headers: {'Authorization': `Bearer ${token}`}
                    });

                    if (threatsResponse.ok) {
                        const threatsData = await threatsResponse.json();
                        if (threatsData.success) {
                            threatIps.value = threatsData.data;
                        }
                    }

                    // 3. ÌÉÄÏûÑÎùºÏù∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                    const timelineResponse = await fetch(`/api/v1/admin/dashboard/events/timeline?timeRange=${selectedTimeRange.value}`, {
                        headers: {'Authorization': `Bearer ${token}`}
                    });

                    if (timelineResponse.ok) {
                        const timelineData = await timelineResponse.json();
                        if (timelineData.success) {
                            updateTimelineChart(timelineData.data);
                        }
                    }

                    // 4. ÏãúÍ∞ÑÎåÄÎ≥Ñ Ìå®ÌÑ¥ ÏóÖÎç∞Ïù¥Ìä∏
                    const hourlyResponse = await fetch('/api/v1/admin/dashboard/patterns/hourly', {
                        headers: {'Authorization': `Bearer ${token}`}
                    });

                    if (hourlyResponse.ok) {
                        const hourlyData = await hourlyResponse.json();
                        if (hourlyData.success) {
                            updateHourlyChart(hourlyData.data);
                        }
                    }

                    // 5. ÏùëÎãµÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                    const responseTimeResponse = await fetch(`/api/v1/admin/dashboard/performance/response-times?timeRange=${selectedTimeRange.value}`, {
                        headers: {'Authorization': `Bearer ${token}`}
                    });

                    if (responseTimeResponse.ok) {
                        const responseTimeData = await responseTimeResponse.json();
                        if (responseTimeData.success) {
                            updateResponseTimeChart(responseTimeData.data);
                        }
                    }

                } catch (error) {
                    console.warn('API Ìò∏Ï∂ú Ïã§Ìå®:', error);
                    // Ìè¥Î∞± Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö© Í∞ÄÎä•
                }

                lastUpdateTime.value = new Date().toLocaleTimeString();
            }

            // ÌÉÄÏûÑÎùºÏù∏ Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            function updateTimelineChart(data) {
                if (!charts.realTime || !data || data.length === 0) return;

                const labels = data.map(item => {
                    const date = new Date(item.timestamp);
                    return date.toLocaleTimeString();
                });

                const bruteforceData = data.map(item => item.bruteforceCount || 0);
                const ddosData = data.map(item => item.ddosCount || 0);
                const scanningData = data.map(item => item.scanningCount || 0);

                charts.realTime.data.labels = labels;
                charts.realTime.data.datasets[0].data = bruteforceData;
                charts.realTime.data.datasets[1].data = ddosData;
                charts.realTime.data.datasets[2].data = scanningData;

                charts.realTime.update('none');
            }

            // ÏãúÍ∞ÑÎåÄÎ≥Ñ Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            function updateHourlyChart(data) {
                if (!charts.hourly || !data || data.length === 0) return;

                const hourlyData = new Array(24).fill(0);
                data.forEach(item => {
                    if (item.hour >= 0 && item.hour < 24) {
                        hourlyData[item.hour] = item.attackCount || 0;
                    }
                });

                charts.hourly.data.datasets[0].data = hourlyData;
                charts.hourly.update('none');
            }

            // ÏùëÎãµÏãúÍ∞Ñ Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            function updateResponseTimeChart(data) {
                if (!charts.responseTime || !data || data.length === 0) return;

                const labels = data.map(item => {
                    const date = new Date(item.timestamp);
                    return date.toLocaleTimeString();
                });

                const responseTimeData = data.map(item => item.averageResponseTime || 0);
                const thresholdData = new Array(data.length).fill(500);

                charts.responseTime.data.labels = labels;
                charts.responseTime.data.datasets[0].data = responseTimeData;
                charts.responseTime.data.datasets[1].data = thresholdData;

                charts.responseTime.update('none');
            }

            // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
            function formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            }

            function formatTime(timestamp) {
                return new Date(timestamp).toLocaleTimeString();
            }

            function getThreatColor(risk) {
                const colorMap = {
                    'CRITICAL': '#dc3545',
                    'HIGH': '#fd7e14',
                    'MEDIUM': '#ffc107',
                    'LOW': '#28a745'
                };
                return colorMap[risk] || '#6c757d';
            }

            // ÏÇ¨Ïö©Ïûê Ïï°ÏÖò Ìï®ÏàòÎì§
            function refreshAllData() {
                updateData();
                // Î™®Îì† Ï∞®Ìä∏ ÏÉàÎ°úÍ≥†Ïπ®
                Object.values(charts).forEach(chart => {
                    if (chart && typeof chart.update === 'function') {
                        chart.update();
                    }
                });
            }

            function updateTimeRange() {
                console.log(`ÏãúÍ∞Ñ Î≤îÏúÑ Î≥ÄÍ≤Ω: ${selectedTimeRange.value}`);
                updateData();
            }

            async function testAlert() {
                const token = localStorage.getItem('accessToken');

                try {
                    const response = await fetch('/api/v1/admin/security/alerts/test', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        console.log('ÌÖåÏä§Ìä∏ ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å');
                    }
                } catch (error) {
                    console.error('ÌÖåÏä§Ìä∏ ÏïåÎ¶º Ïã§Ìå®:', error);
                    // ÏßÅÏ†ë ÌÖåÏä§Ìä∏ ÏïåÎ¶º ÏÉùÏÑ±
                    handleSecurityAlert({
                        title: 'üß™ ÌÖåÏä§Ìä∏ Î≥¥Ïïà ÏïåÎ¶º',
                        message: 'Ïù¥Í≤ÉÏùÄ ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏ ÏïåÎ¶ºÏûÖÎãàÎã§.\nÎ™®Îì† Í∏∞Îä•Ïù¥ Ï†ïÏÉÅ ÏûëÎèôÏ§ëÏûÖÎãàÎã§.',
                        severity: 'MEDIUM',
                        alertKey: 'test-' + Date.now(),
                        ipAddress: '192.168.1.100'
                    });
                }
            }

            function exportReport() {
                console.log('Î¶¨Ìè¨Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Í∏∞Îä• (Íµ¨ÌòÑ ÏòàÏ†ï)');
                alert('Î¶¨Ìè¨Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Í∏∞Îä•Ïù¥ Í≥ß Ï∂úÏãúÎê©ÎãàÎã§!');
            }

            async function acknowledgeAlert(alert) {
                const token = localStorage.getItem('accessToken');

                try {
                    await fetch('/api/v1/admin/security/alerts/acknowledge', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({alertKey: alert.alertKey})
                    });

                    removeAlert(alert.id);
                    console.log('ÏïåÎ¶º ÌôïÏù∏ Ï≤òÎ¶¨Îê®');
                } catch (error) {
                    console.error('ÏïåÎ¶º ÌôïÏù∏ Ïã§Ìå®:', error);
                    removeAlert(alert.id);
                }
            }

            async function suppressAlert(alert, hours) {
                const token = localStorage.getItem('accessToken');

                try {
                    await fetch('/api/v1/admin/security/alerts/suppress', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            alertKey: alert.alertKey,
                            suppressHours: hours
                        })
                    });

                    removeAlert(alert.id);
                    console.log(`${hours}ÏãúÍ∞Ñ ÎèôÏïà ÏïåÎ¶º ÏñµÏ†úÎê®`);
                } catch (error) {
                    console.error('ÏïåÎ¶º ÏñµÏ†ú Ïã§Ìå®:', error);
                    removeAlert(alert.id);
                }
            }

            function blockIp(ipAddress) {
                if (confirm(`IP ${ipAddress}Î•º Ï∞®Îã®ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    console.log(`IP Ï∞®Îã® ÏöîÏ≤≠: ${ipAddress}`);
                    // Ïã§Ï†ú IP Ï∞®Îã® API Ìò∏Ï∂ú
                    alert(`IP ${ipAddress} Ï∞®Îã® ÏöîÏ≤≠Ïù¥ Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.`);
                }
            }

            function removeAlert(alertId) {
                const index = alerts.value.findIndex(alert => alert.id === alertId);
                if (index > -1) {
                    alerts.value.splice(index, 1);
                }
            }

            // ÌÖúÌîåÎ¶øÏóêÏÑú ÏÇ¨Ïö©Ìï† Ìï®ÏàòÎì§ Î∞òÌôò
            return {
                // Î∞òÏùëÌòï Îç∞Ïù¥ÌÑ∞
                connectionStatus,
                connectionStatusText,
                selectedTimeRange,
                lastUpdateTime,
                alerts,
                metrics,
                threatIps,

                // Ìï®ÏàòÎì§
                formatNumber,
                formatTime,
                getThreatColor,
                refreshAllData,
                updateTimeRange,
                testAlert,
                exportReport,
                acknowledgeAlert,
                suppressAlert,
                blockIp,
                removeAlert
            };

        }
    }).mount('#app');
</script>
</body>
</html>